<html>
    <head>
        <title>Refusion Charts</title>
        <script type="text/javascript" src="raphael-min.js"></script>
    </head>
    <body>
    <script type="text/javascript">
    
    var dimension=[900,600],
        paper = Raphael(0, 0, dimension[0], dimension[1]),
        chart_dimension=new Array(2),
        values={
            "chart": {
                "caption": "Product-wise quarterly revenue in current year",
                "subCaption": "FusionChart",
                "xAxisname": "Quarter",
                "yAxisName": "Revenue (In USD)",
                "numberPrefix": "$",
                "paletteColors": ["#0075c2","#1aaf5d"],
                "bgColor": "#FFA500",
                "borderAlpha": "20",
                "showCanvasBorder": "0",
                "usePlotGradientColor": "1",
                "plotBorderAlpha": "10",
                "legendBorderAlpha": "0",
                "legendShadow": "0",
                "valueFontColor": "#ffffff",
                "showXAxisLine": "1",
                "xAxisLineColor": "#999999",
                "divlineColor": "#999999",
                "divLineDashed": "1",
                "showAlternateHGridColor": "0",
                "subcaptionFontBold": "0",
                "subcaptionFontSize": "14",
                "showHoverEffect": "1"
            },

            "categories": [
                {
                    "category": [
                    {
                        "label": "Q1"
                    },
                    {
                        "label": "Q2"
                    },
                    {
                        "label": "Q3"
                    },
                    {
                        "label": "Q4"
                    }
                ]
            }
            ],

            "dataset": [
                {
                    "seriesname": "Food Products",
                    "data": [
                        {
                            "value": 121
                        },
                        {
                            "value": 135
                        },
                        {
                            "value": 123.5
                        },
                        {
                            "value": 145
                        }
                    ]
                },
            
                {
                    "seriesname": "Non-Food \n Products",
                    "data": [
                        {
                            "value": 131.4
                        },
                        {
                            "value": 154.8
                        },
                        {
                            "value": 98.3
                        },
                        {
                            "value": 131.8
                        }
                    ]
                }
            ],

            "margin" : {
                "upDown" : {
                    "caption": 0.05,
                    "subCaption": 0.1,
                    "chartArea": 0.85,
                    "xAxislabel" : 0.9,
                    "xAxisName" : 0.95,
                    "end_point" : 1
                },
                "leftRight" : {
                    "yAxislabel" : 0.05,
                    "yAxisName" : 0.1,
                    "right_part": 0.9,
                    "trendnote" : 1
                }    
            },
            "trendlines": [
                {
                    "line": [
                        {
                            "startvalue": "190",
                            "type" : "-",
                            "valueOnRight": "1",
                            "displayvalue": "Monthly \n Target"
                        }
                    ]
                }
            ]

        },

        no_of_data = values.dataset[0].data.length,

        upDownMargin=[values.margin.upDown.caption, values.margin.upDown.subCaption , values.margin.upDown.chartArea, values.margin.upDown.xAxislabel, values.margin.upDown.xAxisName, values.margin.upDown.end_point],

        leftRightMargin=[values.margin.leftRight.yAxislabel, values.margin.leftRight.yAxisName, values.margin.leftRight.right_part, values.margin.leftRight.trendnote],

        spacing = ((leftRightMargin[2] - leftRightMargin[1])* dimension[0])/(no_of_data+1),

        chart_origin=[leftRightMargin[1]*dimension[0],upDownMargin[2]*dimension[1]],
        i=0,
        column_local_origin=new Array(2),
        maximum_data=0,
        scale_factor=1,
        increment,
        benchmark=0,
        sum,
        width= spacing*0.5,
        column_local_origin1=new Array(2),
        column_local_origin2=new Array(2);
        

        
    //The stack behaves as a column chart when indivual elements are added.So this sum_data() returns the summed value for each dataset.
    sum= (function sum_data(){
        var sum=new Array(no_of_data);
        for(i=0;i<no_of_data;i++){
            sum[i]= values.dataset[0].data[i].value + values.dataset[1].data[i].value; 
        }
        return sum;
    })();
    
    //returns the maximum value available. Maximum data value is  very useful for allocating finding the scale factor.
    function get_max(){
        
        for(i=0;i<no_of_data;i++){
            if(sum[i] > maximum_data){
                maximum_data=sum[i];
            }
        }
        return maximum_data;
    }

    scale_factor=((upDownMargin[2]-upDownMargin[1])*dimension[1])/(1.1*get_max());
    increment = Math.round((1.05 *get_max())/5);

    //This part can be optional, but can be called if there is a target to be fulfilled.     
    function trendline(){
        paper.path("M"+""+chart_origin[0]+" "+(chart_origin[1]-((values.trendlines[0].line[0].startvalue)*scale_factor))+"L"+(chart_origin[0]+((leftRightMargin[2]-leftRightMargin[1])*dimension[0]))+" "+(chart_origin[1]-((values.trendlines[0].line[0].startvalue)*scale_factor)))
        .attr({ "fill": ""+values.trendlines[0].line[0].color, "stroke-dasharray": "--"});
    
        paper.text(((leftRightMargin[3]+leftRightMargin[2])/2)*dimension[0],(chart_origin[1]-((values.trendlines[0].line[0].startvalue)*scale_factor)),""+values.trendlines[0].line[0].displayvalue);
    }

    //format_background() as the name suggest is to print the borders for both window and chart area(Area covered only by charts).It displays the captions, sub captions, labels, legends, etc.
    (function format_background(){
        paper.rect(0,0,dimension[0],dimension[1]).attr({fill:""+values.chart.bgColor});

        paper.rect(leftRightMargin[1]*dimension[0],upDownMargin[1]*dimension[1],(leftRightMargin[2]-leftRightMargin[1])*dimension[0],(upDownMargin[2]-upDownMargin[1])*dimension[1]).attr({"fill":"fff"});
     
        trendline();
        
        paper.text((dimension[0]/2),(upDownMargin[0]*dimension[1]/2),""+values.chart.caption )
                    .attr({ "font-size": 12, "font-family": "Arial, Helvetica, sans-serif" });

        paper.text(dimension[0]/2, dimension[1]*(upDownMargin[1]+upDownMargin[0])/2, ""+values.chart.subCaption)
             .attr({ "font-size": 12, "font-family": "Arial, Helvetica, sans-serif" });

        paper.text(((leftRightMargin[2]+leftRightMargin[1])/2)*dimension[0],dimension[1]*0.5*(upDownMargin[4]+upDownMargin[3]) , ""+values.chart.xAxisname)
             .attr({ "font-size": 10, "font-family": "Arial, Helvetica, sans-serif", "fill": "#000" });

        paper.text(0.5*leftRightMargin[0]*dimension[0],0.5*(upDownMargin[2]+upDownMargin[1])*dimension[1] , ""+values.chart.yAxisName)
             .rotate(-90);

        paper.rect((1.15*0.5*dimension[0]*(leftRightMargin[2]+leftRightMargin[1])),(0.5*dimension[1]*(upDownMargin[5]+upDownMargin[3])),0.5*dimension[1]*(upDownMargin[5]-upDownMargin[4]),0.5*dimension[1]*(upDownMargin[5]-upDownMargin[4])).attr({fill:''+values.chart.paletteColors[1]});

        paper.text((1.25*0.5*dimension[0]*(leftRightMargin[2]+leftRightMargin[1])),(0.5*dimension[1]*(upDownMargin[5]+upDownMargin[4])),'' + values.dataset[1].seriesname);

        paper.rect((0.6*0.5*dimension[0]*(leftRightMargin[2]+leftRightMargin[1])),(0.5*dimension[1]*(upDownMargin[5]+upDownMargin[3])),0.5*dimension[1]*(upDownMargin[5]-upDownMargin[4]),0.5*dimension[1]*(upDownMargin[5]-upDownMargin[4])).attr({fill:''+values.chart.paletteColors[0]});

        paper.text((0.75*0.5*dimension[0]*(leftRightMargin[2]+leftRightMargin[1])),(0.5*dimension[1]*(upDownMargin[5]+upDownMargin[4])), '' + values.dataset[0].seriesname);       
   
    })();

    //format_chartArea is specific to the chart area only. The entire Y-axis is divided into 5 equispaced gaps for the convinience.

    (function format_chartArea(){
        for(i=0;i<=5;i++){
            paper.text(0.45*dimension[0]*(leftRightMargin[1]+leftRightMargin[0]),(chart_origin[1]-(i*increment*scale_factor)),""+values.chart.numberPrefix+" "+benchmark);
            paper.path("M"+""+chart_origin[0]+" "+(chart_origin[1]-(i*increment*scale_factor))+"L"+(leftRightMargin[2]*dimension[0])+" "+(chart_origin[1]-(i*increment*scale_factor)))
            .attr({"stroke-dasharray": ". "});
            benchmark+=increment;
        }
    })();
    

    //render_col2DStack is required to render the 2D stack chart
    (function render_col2DStack(){
        
        for(i=0;i<no_of_data;i++){  
            
            //calculating the local origin for each column in the stack.
            column_local_origin1 = [(chart_origin[0]+(spacing*(i+1))),(chart_origin[1]-((values.dataset[0].data[i].value)*scale_factor))];
            column_local_origin2 = [(chart_origin[0]+(spacing*(i+1))),(chart_origin[1]-(sum[i]*scale_factor))];

            // the following if-else block is to determine if a gradient is required or not.
            if(values.chart.usePlotGradientColor!=0){
                paper.rect(column_local_origin2[0], column_local_origin2[1], width , ((sum[i])*scale_factor)).attr({fill:'90-#fff-'+values.chart.paletteColors[1]});
                paper.rect(column_local_origin1[0], column_local_origin1[1], width , ((values.dataset[0].data[i].value)*scale_factor)).attr({fill:'90-#fff-'+values.chart.paletteColors[0]});
                
            }

            else
            {
                paper.rect(column_local_origin2[0], column_local_origin2[1], width , ((sum[i])*scale_factor)).attr({fill: ''+values.chart.paletteColors[1]});
                paper.rect(column_local_origin1[0], column_local_origin1[1], width , ((values.dataset[0].data[i].value)*scale_factor)).attr({fill:''+values.chart.paletteColors[0]});  
            }
           
            // when the inter-spacings of columns are reduced, we might need to rotate the labels of X-axis for a better view. Generally increasing the number of dataset when required to be visualised in a limited space, the spacings are reduced
            if(spacing<=70){
                paper.text(column_local_origin1[0]+(width/2),(upDownMargin[3]+upDownMargin[2])*0.5*dimension[1], ""+values.categories[0].category[i].label).rotate(-90);


            }
            else{
                paper.text(column_local_origin1[0]+(width/2),(upDownMargin[3]+upDownMargin[2])*0.5*dimension[1], ""+values.categories[0].category[i].label);
            }

            paper.text(column_local_origin1[0]+(width/2),(1.1*column_local_origin1[1]), ""+values.chart.numberPrefix+values.dataset[0].data[i].value).attr({fill: "#fff"})  ;

            paper.text(column_local_origin2[0]+(width/2),(1.1*column_local_origin2[1]), ""+values.chart.numberPrefix+values.dataset[1].data[i].value).attr({fill: "#fff"});

        }
    })();

    </script>
	</body>
</html>
